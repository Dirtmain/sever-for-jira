name: Playwright -> Update existing RTM Test Execution

on:
  workflow_dispatch:
    inputs:
      executionKey:
        description: "Existing RTM Test Execution key (np. ECS-67)"
        required: true
      environment:
        description: "Środowisko"
        type: choice
        options: [TEST, PROD]
        required: true
      tenant:
        description: "Tenant"
        type: choice
        options: [BYDGOSZCZ, GRUDZIADZ, TORUN]
        required: true

jobs:
  e2e:
    runs-on: ubuntu-latest

    env:
      RTM_BASE_URL: https://rtm-eu-api.hexygen.com
      RTM_PROJECT_KEY: ECS
      CI: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies + Playwright
        run: |
          npm ci
          npx playwright install --with-deps

      # 1) Pobierz Test Execution (ECS-67) i zbuduj:
      # - mapowanie: TestCaseKey (np. ECS-63) -> TestCaseExecutionKey (TCE key)
      # - grep regex do Playwright, żeby odpalić tylko testy z tej egzekucji
      - name: Fetch RTM execution + build TCE mapping
        env:
          RTM_API_TOKEN: eyJhbGciOiJIUzM4NCJ9.eyJzdWIiOiI0OTIyNTkifQ.7Ne6V2Kn5t-KC-FLAWhMEH5xme1qSRCnH3OMT8x_6Ec1859lb1vgjDL8dIzaure7
          EXECUTION_KEY: ${{ inputs.executionKey }}
        run: |
          set -euo pipefail
          mkdir -p .rtm

          echo "Downloading Test Execution: ${EXECUTION_KEY}"
          curl -sS -f \
            -H "Authorization: Bearer ${RTM_API_TOKEN}" \
            "${RTM_BASE_URL}/api/v2/test-execution/${EXECUTION_KEY}" \
            -o .rtm/execution.json

      - name: print json because shit pmo
        if: always()
        run: |
          echo "=== .rtm/execution.json ==="
          head -n 200 .rtm/execution.json || true
          echo ""      


      - name: Debug list discovered tests
        run: npx playwright test --list
  

      # 2) Uruchom Playwright (filtrowanie jeśli grep jest zbudowany)
      - name: Run Playwright (JUnit)
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          TENANT: ${{ inputs.tenant }}
          PLAYWRIGHT_JUNIT_OUTPUT_DIR: test-results
          PLAYWRIGHT_JUNIT_OUTPUT_NAME: results.xml
        run: |
          set -euo pipefail
          mkdir -p test-results

          GREP="$(cat .rtm/grep.txt || true)"
          if [ -n "${GREP}" ]; then
            echo "Running Playwright with --grep '${GREP}'"
            npx playwright test --grep "${GREP}" --reporter=junit,line
          else
            echo "No grep built from RTM execution; running full test suite"
            npx playwright test --reporter=junit,line
          fi

      - name: Show JUnit file
        if: always()
        run: |
          ls -la test-results || true
          test -f test-results/results.xml && head -n 40 test-results/results.xml || true

      # 3) Sparsuj JUnit i aktualizuj TCE wyniki w ISTNIEJĄCEJ egzekucji (ECS-67)
      #
      # UWAGA: payload do update bywa różny zależnie od wersji RTM.
      # Ten krok próbuje po kolei kilka wariantów body:
      #  - {"status":{"name":"Pass"}} / {"status":{"name":"Fail"}}
      #  - {"resultStatus":{"name":"Pass"}} / ...
      #  - {"result":{"name":"Pass"}} / ...
      #
      # Jeśli Twoje RTM oczekuje innych nazw (np. "PASSED"/"FAILED"), zmień RTM_PASS/RTM_FAIL poniżej.
      - name: Update RTM Test Case Executions from JUnit
        if: always()
        env:
          RTM_API_TOKEN: eyJhbGciOiJIUzM4NCJ9.eyJzdWIiOiI0OTIyNTkifQ.7Ne6V2Kn5t-KC-FLAWhMEH5xme1qSRCnH3OMT8x_6Ec1859lb1vgjDL8dIzaure7
          EXECUTION_KEY: ${{ inputs.executionKey }}
          RTM_PASS: Pass
          RTM_FAIL: Fail
        run: |
          set -euo pipefail

          if [ ! -f test-results/results.xml ]; then
            echo "No JUnit file found (test-results/results.xml). Skipping RTM update."
            exit 0
          fi

          # Build results map: TestCaseKey -> PASS/FAIL
          echo "Building mapping + grep pattern from execution.json"

          # Build TC -> TCE map:
          # "ECS-63": "ECS-67-ECS-63"
          jq --arg exec "$EXECUTION_KEY" '
          (.testCaseExecutions // [])
          | map(.testKey)
          | map(select(startswith($exec + "-")))
          | map({ (sub("^" + ($exec + "-"); "")) : . })
          | add // {}
          ' .rtm/execution.json > .rtm/tce_map.json

          # Build grep from TC keys (ECS-63 etc.) and @ECS-63
          if [ "$(jq 'length' .rtm/tce_map.json)" -gt 0 ]; then
          jq -r '
          keys as $k
          | ($k + ($k | map("@" + .)))
          | unique
          | "(" + (join("|")) + ")"
          ' .rtm/tce_map.json > .rtm/grep.txt
          else
          echo "" > .rtm/grep.txt
          fi

          python3 scripts/rtm_extract_outcomes.py
          echo "Outcomes extracted from JUnit:"
          cat .rtm/outcomes.json || true

          # For each TestCaseKey outcome, update its TCE (if mapping exists)
          # We attempt multiple payload shapes to match your RTM version.
          jq -r 'to_entries[] | "\(.key) \(.value)"' .rtm/outcomes.json | while read -r TC_KEY OUTCOME; do
            TCE_KEY="$(jq -r --arg k "$TC_KEY" '.[$k] // empty' .rtm/tce_map.json)"
            if [ -z "$TCE_KEY" ] || [ "$TCE_KEY" = "null" ]; then
              echo "WARN: No TCE mapping for TC=${TC_KEY}. Skipping."
              continue
            fi

            if [ "$OUTCOME" = "PASS" ]; then
              STATUS_NAME="${RTM_PASS}"
            else
              STATUS_NAME="${RTM_FAIL}"
            fi

            echo "Updating TCE=${TCE_KEY} (from TC=${TC_KEY}) => ${STATUS_NAME}"

            URL="${RTM_BASE_URL}/api/v2/test-case-execution/${TCE_KEY}"

            # Try payload #1: status.name
            CODE="$(curl -sS -o /tmp/rtm_resp.json -w "%{http_code}" \
              -X PUT \
              -H "Authorization: Bearer ${RTM_API_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"status\":{\"name\":\"${STATUS_NAME}\"}}" \
              "${URL}" || true)"
            if [ "$CODE" = "200" ] || [ "$CODE" = "204" ]; then
              echo "OK (status.name) ${TCE_KEY}"
              continue
            fi

            # Try payload #2: resultStatus.name
            CODE="$(curl -sS -o /tmp/rtm_resp.json -w "%{http_code}" \
              -X PUT \
              -H "Authorization: Bearer ${RTM_API_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"resultStatus\":{\"name\":\"${STATUS_NAME}\"}}" \
              "${URL}" || true)"
            if [ "$CODE" = "200" ] || [ "$CODE" = "204" ]; then
              echo "OK (resultStatus.name) ${TCE_KEY}"
              continue
            fi

            # Try payload #3: result.name
            CODE="$(curl -sS -o /tmp/rtm_resp.json -w "%{http_code}" \
              -X PUT \
              -H "Authorization: Bearer ${RTM_API_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"result\":{\"name\":\"${STATUS_NAME}\"}}" \
              "${URL}" || true)"
            if [ "$CODE" = "200" ] || [ "$CODE" = "204" ]; then
              echo "OK (result.name) ${TCE_KEY}"
              continue
            fi

            echo "ERROR: Could not update TCE=${TCE_KEY}. HTTP=${CODE}. Response:"
            cat /tmp/rtm_resp.json || true
            echo ""
          done

      # (Opcjonalnie) wrzuć JUnit jako artifact do GitHuba
      - name: Upload JUnit artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: junit-results
          path: test-results/results.xml
